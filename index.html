<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quick Statistics — Two Variables</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b0f17; --card:#121a28; --text:#e8eefc; --muted:#a9b6d3; --line:#23304a;
      --btn:#1f6feb; --ok:#2ea043;
    }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); }
    .wrap{ max-width:1280px; margin:0 auto; padding:18px; }
    h1{ font-size:22px; margin:6px 0 10px; }
    .sub{ color:var(--muted); margin:0 0 16px; }

    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:14px; }
    @media (max-width:980px){ .grid2{ grid-template-columns:1fr; } }

    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; box-shadow:0 8px 20px rgba(0,0,0,.25); }
    textarea{
      width:100%; min-height:140px; resize:vertical; background:#0e1524; border:1px solid var(--line);
      color:var(--text); border-radius:12px; padding:12px; font-size:14px; line-height:1.35; outline:none;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; align-items:center; }
    button{ border:1px solid var(--line); background:#0e1524; color:var(--text); padding:10px 12px; border-radius:12px; cursor:pointer; }
    button.primary{ background:var(--btn); border-color:transparent; }
    button.success{ background:var(--ok); border-color:transparent; }
    button:hover{ filter:brightness(1.08); }

    .meta{ margin-top:10px; color:var(--muted); font-size:13px; }
    .small{ font-size:13px; color:var(--muted); }
    .titleRow{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; }
    .toast{ margin-left:auto; color:var(--muted); font-size:13px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .plots3{ display:grid; grid-template-columns: 0.75fr 0.75fr 1.5fr; gap:14px; align-items:start; }
    @media (max-width:980px){ .plots3{ grid-template-columns:1fr; } }

    /* smaller hist/density */
    .hSmall{ height:140px !important; }
    .dSmall{ height:120px !important; }

    /* boxplot: wide */
    canvas.boxCanvas{ width:100%; height:210px; display:block; touch-action:none; }

    .stats{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px; }
    @media (max-width:520px){ .stats{ grid-template-columns:1fr; } }
    .kv{ border:1px solid var(--line); border-radius:12px; padding:10px; background:#0e1524; }
    .kv .k{ color:var(--muted); font-size:12px; }
    .kv .v{ font-size:16px; margin-top:2px; }

    .note{ margin-top:12px; padding:10px 12px; border-radius:12px; border:1px solid var(--line); background:#0e1524; color:var(--text); }
    .note .title{ font-weight:650; margin-bottom:6px; }

    .tip{
      position: fixed; z-index: 9999; display:none; max-width: 360px;
      background:#0e1524; border:1px solid var(--line); border-radius:12px; padding:10px 12px;
      color:var(--text); box-shadow:0 12px 28px rgba(0,0,0,.35); pointer-events:none;
      font-size:12.5px; line-height:1.25;
    }
    .tip .t{ font-weight:650; margin-bottom:6px; }
    .tip .m{ color:var(--muted); }
    .tip .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    /* -------------------- ADDED: PayPal donate button styled like buttons -------------------- */
    a.btnLike{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      text-decoration:none;
      border:1px solid var(--line);
      background:#0e1524;
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    a.btnLike.primary{ background:var(--btn); border-color:transparent; }
    a.btnLike:hover{ filter:brightness(1.08); }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Quick Statistical Summary (One or Two Variables)</h1>
    <p class="sub">
      Paste numbers for <strong>Variable X</strong> and <strong>Variable Y</strong> (separators: comma, semicolon, whitespace, newline).
      All computations run locally in your browser.
    </p>

    <div class="grid2">
      <div class="card">
        <div class="titleRow">
          <strong>Variable X</strong>
          <span class="small">independent distribution</span>
        </div>
        <textarea id="dataX" placeholder="Example: 1, 2, 2, 3, 3, 4, 100"></textarea>
        <div class="meta" id="parseX">—</div>
      </div>

      <div class="card">
        <div class="titleRow">
          <strong>Variable Y</strong>
          <span class="small">independent distribution</span>
        </div>
        <textarea id="dataY" placeholder="Example: 5, 6, 7, 8, 9, 10"></textarea>
        <div class="meta" id="parseY">—</div>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="card">
      <div class="row">
        <button class="primary" id="analyze">Analyze</button>
        <button id="example">Load example</button>
        <button id="clear">Clear</button>
        <button class="success" id="copyReport" disabled>Copy combined report</button>

        <!-- -------------------- ADDED: PayPal donate button -------------------- -->
        <a
          class="btnLike primary"
          href="https://www.paypal.me/JHolm169"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Donate via PayPal"
          title="Donate via PayPal"
        >
          Donate (PayPal)
        </a>

        <span class="toast" id="toast">—</span>
      </div>
      <div class="small" style="margin-top:8px;">
        If both X and Y are provided, a scatter plot is computed using paired observations by index:
        <span class="mono">(x₁,y₁), (x₂,y₂), …</span> up to <span class="mono">min(nX,nY)</span>.
      </div>
    </div>

    <div style="height:14px"></div>

    <div class="plots3">
      <!-- X -->
      <div class="card">
        <div class="titleRow">
          <strong>X: Histogram</strong>
          <span class="small">Freedman–Diaconis (Tukey IQR)</span>
        </div>
        <canvas id="xHist" class="hSmall" height="140"></canvas>
      </div>
      <div class="card">
        <div class="titleRow">
          <strong>X: Density</strong>
          <span class="small">KDE (Silverman)</span>
        </div>
        <canvas id="xDen" class="dSmall" height="120"></canvas>
      </div>
      <div class="card">
        <div class="titleRow">
          <strong>X: Tukey boxplot</strong>
          <span class="small">hover/tap: box, outliers, whisker tips</span>
        </div>
        <canvas id="xBox" class="boxCanvas" width="1200" height="210"></canvas>
        <div id="xStats" class="stats"></div>
        <div id="xInterp" class="note" style="display:none;"></div>
      </div>

      <!-- Y -->
      <div class="card">
        <div class="titleRow">
          <strong>Y: Histogram</strong>
          <span class="small">Freedman–Diaconis (Tukey IQR)</span>
        </div>
        <canvas id="yHist" class="hSmall" height="140"></canvas>
      </div>
      <div class="card">
        <div class="titleRow">
          <strong>Y: Density</strong>
          <span class="small">KDE (Silverman)</span>
        </div>
        <canvas id="yDen" class="dSmall" height="120"></canvas>
      </div>
      <div class="card">
        <div class="titleRow">
          <strong>Y: Tukey boxplot</strong>
          <span class="small">hover/tap: box, outliers, whisker tips</span>
        </div>
        <canvas id="yBox" class="boxCanvas" width="1200" height="210"></canvas>
        <div id="yStats" class="stats"></div>
        <div id="yInterp" class="note" style="display:none;"></div>
      </div>
    </div>

    <div style="height:14px"></div>

    <div class="card">
      <div class="titleRow">
        <strong>X vs Y: Scatter + regression</strong>
        <span class="small" id="xyNote">Provide both X and Y to view relationship.</span>
      </div>
      <canvas id="xyScatter" height="260"></canvas>
      <div class="small" style="margin-top:10px;" id="xyStats">—</div>
    </div>

    <p class="small" style="margin-top:14px;">
      Single-file static page (no backend). Hosting: GitHub Pages / Cloudflare Pages / Netlify.
    </p>
  </div>

  <div id="boxTip" class="tip"></div>

<script>
  // -------------------- Formatting --------------------
  const fmt = (x) => {
    if (!Number.isFinite(x)) return '—';
    const ax = Math.abs(x);
    const s = (ax >= 1000 ? x.toFixed(2) : x.toFixed(4));
    return s.replace(/\.?0+$/,'');
  };

  // -------------------- Parsing --------------------
  function parseNumbers(raw) {
    const cleaned = raw
      .replace(/[，]/g, ',')
      .replace(/[;]/g, ',')
      .replace(/\s+/g, ' ')
      .trim();

    if (!cleaned) return { nums: [], bad: 0 };

    const tokens = cleaned.split(/[,\s]+/).filter(Boolean);
    let bad = 0;
    const nums = [];
    for (const t0 of tokens) {
      const t = t0;
      const n = Number(t.replace(',', '.'));
      if (Number.isFinite(n)) nums.push(n);
      else bad++;
    }
    return { nums, bad };
  }

  // -------------------- Core stats --------------------
  function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }

  function median(sorted){
    const n = sorted.length;
    const mid = Math.floor(n/2);
    return n % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;
  }

  // Tukey-style quartiles ("median of halves")
  function tukeyQuartiles(sorted){
    const n = sorted.length;
    if (n === 0) return { q1: NaN, q3: NaN };
    const lower = sorted.slice(0, Math.floor(n/2));
    const upper = sorted.slice(Math.ceil(n/2));
    return { q1: median(lower), q3: median(upper) };
  }

  function sampleStd(a){
    const n = a.length;
    if (n < 2) return NaN;
    const m = mean(a);
    let s2 = 0;
    for (const x of a) s2 += (x-m)*(x-m);
    return Math.sqrt(s2/(n-1));
  }

  function freedmanDiaconisBins(sorted){
    const n = sorted.length;
    if (n < 2) return { bins: 1 };
    const { q1, q3 } = tukeyQuartiles(sorted);
    const iqr = q3 - q1;
    const range = sorted[n-1] - sorted[0];
    if (!(iqr > 0) || !(range > 0)) return { bins: Math.ceil(Math.sqrt(n)) };
    const h = 2 * iqr * Math.pow(n, -1/3);
    const bins = Math.max(1, Math.ceil(range / h));
    return { bins };
  }

  function histogram(sorted, bins){
    const n = sorted.length;
    const min = sorted[0], max = sorted[n-1];
    if (min === max) return { labels:[`${fmt(min)}`], counts:[n] };

    const width = (max - min) / bins;
    const counts = new Array(bins).fill(0);
    for (const x of sorted) {
      const idx = Math.min(bins-1, Math.floor((x - min) / width));
      counts[idx]++;
    }
    const labels = [];
    for (let i=0;i<bins;i++){
      const a = min + i*width;
      const b = a + width;
      labels.push(`${fmt(a)}–${fmt(b)}`);
    }
    return { labels, counts };
  }

  function skewSummary(sorted){
    const m = mean(sorted);
    const med = median(sorted);
    const min = sorted[0], max = sorted[sorted.length-1];
    const left = med - min;
    const right = max - med;
    const delta = m - med;
    const tailRatio = right / (left === 0 ? 1e-9 : left);

    if (Math.abs(delta) < 1e-12 && Math.abs(tailRatio - 1) < 0.15) {
      return { label:'approximately symmetric', short:'approximately symmetric', code:'sym' };
    }
    if (delta > 0 && tailRatio > 1.2) return { label:'right-skewed', short:'right-skewed', code:'right' };
    if (delta < 0 && tailRatio < 0.8) return { label:'left-skewed', short:'left-skewed', code:'left' };
    if (delta > 0) return { label:'likely right-skewed', short:'likely right-skewed', code:'right' };
    if (delta < 0) return { label:'likely left-skewed', short:'likely left-skewed', code:'left' };
    return { label:'no clear skewness pattern', short:'no clear skewness pattern', code:'unclear' };
  }

  // -------------------- KDE --------------------
  function kdeGaussian(x, xi, h) {
    const z = (x - xi) / h;
    return Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI);
  }

  function densityKDE(sorted) {
    const n = sorted.length;
    const min = sorted[0], max = sorted[n - 1];
    if (min === max) return { xs: [min], ys: [1] };

    const sd = sampleStd(sorted);
    let h = (Number.isFinite(sd) && sd > 0) ? 1.06 * sd * Math.pow(n, -1/5) : (max - min) / 10;
    if (!Number.isFinite(h) || h <= 0) h = (max - min) / 10;

    const steps = 140;
    const xs = [];
    const ys = [];
    for (let i = 0; i <= steps; i++) {
      const x = min + (max - min) * (i / steps);
      let s = 0;
      for (const xi of sorted) s += kdeGaussian(x, xi, h);
      const y = s / (n * h);
      xs.push(x);
      ys.push(y);
    }
    return { xs, ys };
  }

  // -------------------- Boxplot drawing + tooltips --------------------
  const tip = document.getElementById('boxTip');
  function showTip(clientX, clientY, html){
    tip.innerHTML = html;
    const pad = 12;
    tip.style.display = 'block';
    const rect = tip.getBoundingClientRect();
    let x = clientX + 14, y = clientY + 14;
    if (x + rect.width + pad > window.innerWidth) x = clientX - rect.width - 14;
    if (y + rect.height + pad > window.innerHeight) y = clientY - rect.height - 14;
    tip.style.left = `${Math.max(pad, x)}px`;
    tip.style.top  = `${Math.max(pad, y)}px`;
  }
  function hideTip(){ tip.style.display = 'none'; }

  function canvasClientToLocal(canvas, clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const x = (clientX - r.left) * (canvas.clientWidth / r.width);
    const y = (clientY - r.top)  * (canvas.clientHeight / r.height);
    return { x, y };
  }
  function dist2(ax, ay, bx, by){
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  }

  // store geometry per canvas id
  const BOX_GEOM = new Map();

  function tipHTML_box(geom, label){
    const s = geom.summary;
    return `
      <div class="t">${label}: Box summary</div>
      <div><span class="m">Median:</span> <span class="mono">${fmt(s.medianVal)}</span></div>
      <div class="m" style="margin-top:6px;">
        n = <span class="mono">${s.n}</span>,
        Q1 = <span class="mono">${fmt(s.q1)}</span>,
        Q3 = <span class="mono">${fmt(s.q3)}</span>,
        IQR = <span class="mono">${fmt(s.iqr)}</span>,
        outliers = <span class="mono">${s.outliersCount}</span>
      </div>
    `;
  }
  function tipHTML_outlier(geom, label, v){
    const s = geom.summary;
    return `
      <div class="t">${label}: Outlier</div>
      <div><span class="m">Value:</span> <span class="mono">${fmt(v)}</span></div>
      <div class="m" style="margin-top:6px;">
        Tukey fences: <span class="mono">&lt; ${fmt(s.lo)}</span> or <span class="mono">&gt; ${fmt(s.hi)}</span>
      </div>
    `;
  }
  function tipHTML_whisker(label, side, value, fence){
    const lbl = side === 'lower' ? 'Lower whisker' : 'Upper whisker';
    const fenceLbl = side === 'lower' ? 'Lower fence' : 'Upper fence';
    return `
      <div class="t">${label}: ${lbl}</div>
      <div><span class="m">Whisker value:</span> <span class="mono">${fmt(value)}</span></div>
      <div class="m" style="margin-top:6px;">
        ${fenceLbl}: <span class="mono">${fmt(fence)}</span>
      </div>
    `;
  }

  function drawBoxplot(canvas, label, summary){
    const ctx = canvas.getContext('2d');

    // HiDPI
    const cssW = canvas.clientWidth || canvas.width;
    const cssH = canvas.clientHeight || canvas.height;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const w = cssW, h = cssH;
    ctx.clearRect(0,0,w,h);

    const { n, min, max, q1, q3, iqr, medianVal, lo, hi, outliers } = summary;

    BOX_GEOM.set(canvas.id, null);

    if (!Number.isFinite(min) || !Number.isFinite(max) || min === max){
      ctx.fillStyle = 'rgba(232,238,252,0.85)';
      ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
      ctx.fillText('Not enough variation to draw a boxplot.', 14, 22);
      return;
    }

    const padX = 52;
    const midY = Math.round(h * 0.50);

    const xMap = (v) => {
      const t = (v - min) / (max - min);
      return padX + t * (w - 2*padX);
    };

    const whiskerLow = Math.max(min, lo);
    const whiskerHigh = Math.min(max, hi);

    const xWL = xMap(whiskerLow);
    const xWH = xMap(whiskerHigh);
    const xQ1 = xMap(q1);
    const xQ3 = xMap(q3);
    const xMed = xMap(medianVal);

    // Baseline
    ctx.strokeStyle = 'rgba(169,182,211,0.22)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padX, midY);
    ctx.lineTo(w - padX, midY);
    ctx.stroke();

    // Box
    const boxH = Math.min(70, Math.max(56, Math.round(h * 0.32)));
    const yTop = midY - boxH/2;
    const yBot = midY + boxH/2;

    ctx.fillStyle = 'rgba(31,111,235,0.18)';
    ctx.strokeStyle = 'rgba(31,111,235,0.92)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(xQ1, yTop, (xQ3 - xQ1), boxH);
    ctx.fill();
    ctx.stroke();

    // Median
    ctx.strokeStyle = 'rgba(232,238,252,0.95)';
    ctx.lineWidth = 2.4;
    ctx.beginPath();
    ctx.moveTo(xMed, yTop);
    ctx.lineTo(xMed, yBot);
    ctx.stroke();

    // Whiskers
    ctx.strokeStyle = 'rgba(169,182,211,0.90)';
    ctx.lineWidth = 2.2;

    ctx.beginPath(); ctx.moveTo(xQ1, midY); ctx.lineTo(xWL, midY); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xQ3, midY); ctx.lineTo(xWH, midY); ctx.stroke();

    // Caps
    const capH = 26;
    const yCapTop = midY - capH/2;
    const yCapBot = midY + capH/2;

    ctx.beginPath(); ctx.moveTo(xWL, yCapTop); ctx.lineTo(xWL, yCapBot); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xWH, yCapTop); ctx.lineTo(xWH, yCapBot); ctx.stroke();

    // Outliers
    const outR = 6;
    ctx.fillStyle = 'rgba(232,238,252,0.98)';
    ctx.strokeStyle = 'rgba(232,238,252,0.55)';
    ctx.lineWidth = 1;

    const outPoints = [];
    for (const v of outliers){
      const x = xMap(v);
      outPoints.push({ x, y: midY, v });
      ctx.beginPath();
      ctx.arc(x, midY, outR, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }

    // Labels
    ctx.fillStyle = 'rgba(169,182,211,0.90)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText(`min ${fmt(min)}`, 10, h - 12);
    const maxLabel = `max ${fmt(max)}`;
    const maxW = ctx.measureText(maxLabel).width;
    ctx.fillText(maxLabel, w - 10 - maxW, h - 12);

    BOX_GEOM.set(canvas.id, {
      label,
      boxRect: { x1: xQ1, x2: xQ3, y1: yTop, y2: yBot },
      outR, outPoints,
      whisker: {
        low:  { x: xWL, yTop: yCapTop, yBot: yCapBot, value: whiskerLow, fence: lo },
        high: { x: xWH, yTop: yCapTop, yBot: yCapBot, value: whiskerHigh, fence: hi }
      },
      summary: { n, q1, q3, iqr, medianVal, outliersCount: outliers.length, lo, hi }
    });
  }

  // Priority: outlier > whisker > box
  function hitTestBoxplot(canvas, clientX, clientY){
    const geom = BOX_GEOM.get(canvas.id);
    if (!geom) return { kind:'none' };

    const { x, y } = canvasClientToLocal(canvas, clientX, clientY);

    // Outliers
    const tol = 6;
    const r = geom.outR + tol;
    const r2 = r*r;
    let best = null;
    for (const p of geom.outPoints){
      const d = dist2(x,y,p.x,p.y);
      if (d <= r2 && (!best || d < best.d)) best = { kind:'outlier', v: p.v, d };
    }
    if (best) return best;

    // Whisker tips
    const xTol = 10, yTol = 8;
    const wl = geom.whisker.low;
    const wh = geom.whisker.high;

    if (Math.abs(x - wl.x) <= xTol && y >= (wl.yTop - yTol) && y <= (wl.yBot + yTol)){
      return { kind:'whisker', side:'lower', value: wl.value, fence: wl.fence };
    }
    if (Math.abs(x - wh.x) <= xTol && y >= (wh.yTop - yTol) && y <= (wh.yBot + yTol)){
      return { kind:'whisker', side:'upper', value: wh.value, fence: wh.fence };
    }

    // Box
    const b = geom.boxRect;
    const pad = 6;
    if (x >= b.x1 - pad && x <= b.x2 + pad && y >= b.y1 - pad && y <= b.y2 + pad){
      return { kind:'box' };
    }
    return { kind:'none' };
  }

  function attachBoxInteractions(canvas){
    const handle = (clientX, clientY) => {
      const geom = BOX_GEOM.get(canvas.id);
      if (!geom) { hideTip(); return; }
      const hit = hitTestBoxplot(canvas, clientX, clientY);
      if (hit.kind === 'none') { hideTip(); return; }
      if (hit.kind === 'outlier') showTip(clientX, clientY, tipHTML_outlier(geom, geom.label, hit.v));
      else if (hit.kind === 'whisker') showTip(clientX, clientY, tipHTML_whisker(geom.label, hit.side, hit.value, hit.fence));
      else showTip(clientX, clientY, tipHTML_box(geom, geom.label));
    };

    canvas.addEventListener('mousemove', (e) => handle(e.clientX, e.clientY));
    canvas.addEventListener('mouseleave', () => hideTip());

    const onTouchMove = (ev) => {
      if (!ev.touches || ev.touches.length === 0) return;
      const t = ev.touches[0];
      const hit = hitTestBoxplot(canvas, t.clientX, t.clientY);
      if (hit.kind === 'none') { hideTip(); return; }
      ev.preventDefault();
      handle(t.clientX, t.clientY);
    };
    canvas.addEventListener('touchstart', onTouchMove, { passive:false });
    canvas.addEventListener('touchmove',  onTouchMove, { passive:false });
    canvas.addEventListener('touchend',   () => hideTip());
    canvas.addEventListener('touchcancel',() => hideTip());
  }

  // -------------------- Regression & correlation --------------------
  function pearsonR(xs, ys){
    const n = Math.min(xs.length, ys.length);
    if (n < 2) return NaN;
    let sx=0, sy=0;
    for (let i=0;i<n;i++){ sx += xs[i]; sy += ys[i]; }
    const mx = sx/n, my = sy/n;
    let sxx=0, syy=0, sxy=0;
    for (let i=0;i<n;i++){
      const dx = xs[i]-mx, dy = ys[i]-my;
      sxx += dx*dx; syy += dy*dy; sxy += dx*dy;
    }
    if (sxx <= 0 || syy <= 0) return NaN;
    return sxy / Math.sqrt(sxx*syy);
  }

  function linearRegression(xs, ys){
    const n = Math.min(xs.length, ys.length);
    if (n < 2) return { slope: NaN, intercept: NaN };
    let sx=0, sy=0;
    for (let i=0;i<n;i++){ sx += xs[i]; sy += ys[i]; }
    const mx = sx/n, my = sy/n;
    let sxx=0, sxy=0;
    for (let i=0;i<n;i++){
      const dx = xs[i]-mx;
      sxx += dx*dx;
      sxy += dx*(ys[i]-my);
    }
    if (sxx <= 0) return { slope: NaN, intercept: NaN };
    const slope = sxy / sxx;
    const intercept = my - slope*mx;
    return { slope, intercept };
  }

  // -------------------- UI helpers --------------------
  function statCard(k, v){
    const div = document.createElement('div');
    div.className = 'kv';
    div.innerHTML = `<div class="k">${k}</div><div class="v">${v}</div>`;
    return div;
  }

  // chart instances
  const charts = {
    xHist:null, xDen:null,
    yHist:null, yDen:null,
    xy:null
  };

  function destroyChart(key){
    if (charts[key]) charts[key].destroy();
    charts[key] = null;
  }

  // -------------------- Render one variable --------------------
  function renderVariable(prefix, label, nums, bad){
    const parseEl = document.getElementById(prefix === 'x' ? 'parseX' : 'parseY');
    const statsEl = document.getElementById(prefix + 'Stats');
    const interpEl = document.getElementById(prefix + 'Interp');

    // clear charts if empty
    if (nums.length === 0){
      parseEl.textContent = `No data. (Ignored ${bad} invalid token(s).)`;
      statsEl.innerHTML = '';
      interpEl.style.display = 'none';
      destroyChart(prefix + 'Hist');
      destroyChart(prefix + 'Den');
      const boxCanvas = document.getElementById(prefix + 'Box');
      boxCanvas.getContext('2d').clearRect(0,0,boxCanvas.width,boxCanvas.height);
      BOX_GEOM.set(boxCanvas.id, null);
      return null;
    }

    const sorted = [...nums].sort((a,b)=>a-b);
    const n = sorted.length;

    const min = sorted[0], max = sorted[n-1];
    const meanVal = mean(sorted);
    const medianVal = median(sorted);
    const sd = sampleStd(sorted);
    const { q1, q3 } = tukeyQuartiles(sorted);
    const iqr = q3 - q1;
    const lo = q1 - 1.5*iqr;
    const hi = q3 + 1.5*iqr;
    const outliers = sorted.filter(x => x < lo || x > hi);
    const skew = skewSummary(sorted);

    parseEl.textContent = `Parsed ${n} number(s). Ignored ${bad} invalid token(s).`;

    // stats cards
    statsEl.innerHTML = '';
    statsEl.appendChild(statCard('n', `${n}`));
    statsEl.appendChild(statCard('min', `${fmt(min)}`));
    statsEl.appendChild(statCard('max', `${fmt(max)}`));
    statsEl.appendChild(statCard('mean', `${fmt(meanVal)}`));
    statsEl.appendChild(statCard('median', `${fmt(medianVal)}`));
    statsEl.appendChild(statCard('sample SD', `${Number.isFinite(sd) ? fmt(sd) : '—'}`));
    statsEl.appendChild(statCard('Q1 (25%)', `${fmt(q1)}`));
    statsEl.appendChild(statCard('Q3 (75%)', `${fmt(q3)}`));
    statsEl.appendChild(statCard('IQR', `${fmt(iqr)}`));
    statsEl.appendChild(statCard('Tukey outliers', outliers.length ? `${outliers.length}` : '0'));

    const meanVsMed = (meanVal > medianVal)
      ? 'Mean > median, consistent with a right-tailed influence of larger values.'
      : (meanVal < medianVal)
        ? 'Mean < median, consistent with a left-tailed influence of smaller values.'
        : 'Mean ≈ median, consistent with approximate symmetry.';

    const outTxt = outliers.length
      ? `Outliers (Tukey fences): values < ${fmt(lo)} or > ${fmt(hi)} (count = ${outliers.length}).`
      : `No outliers detected by Tukey fences (< ${fmt(lo)} or > ${fmt(hi)}).`;

    interpEl.style.display = 'block';
    interpEl.innerHTML = `
      <div class="title">Interpretation</div>
      <div>• Distribution: <span class="mono">${skew.label}</span>.</div>
      <div>• ${meanVsMed}</div>
      <div>• ${outTxt}</div>
    `;

    // histogram
    const fd = freedmanDiaconisBins(sorted);
    const bins = Math.min(60, Math.max(1, fd.bins));
    const hist = histogram(sorted, bins);
    const histCanvas = document.getElementById(prefix + 'Hist');
    destroyChart(prefix + 'Hist');
    charts[prefix + 'Hist'] = new Chart(histCanvas, {
      type: 'bar',
      data: {
        labels: hist.labels,
        datasets: [{ label:'Count', data: hist.counts, borderWidth: 1 }]
      },
      options: {
        responsive:true,
        plugins:{ legend:{ display:false } },
        scales:{ x:{ ticks:{ display:false } }, y:{ beginAtZero:true } }
      }
    });

    // density
    const den = densityKDE(sorted);
    const denCanvas = document.getElementById(prefix + 'Den');
    destroyChart(prefix + 'Den');
    charts[prefix + 'Den'] = new Chart(denCanvas, {
      type: 'line',
      data: {
        labels: den.xs.map(x => fmt(x)),
        datasets: [{ label:'Density', data: den.ys, pointRadius:0, borderWidth:2, tension:0.25 }]
      },
      options: {
        responsive:true,
        plugins:{ legend:{ display:false } },
        scales:{ x:{ ticks:{ display:false } }, y:{ beginAtZero:true } }
      }
    });

    // boxplot (custom)
    const boxCanvas = document.getElementById(prefix + 'Box');
    drawBoxplot(boxCanvas, label, {
      n, min, max, q1, q3, iqr, medianVal, lo, hi, outliers
    });

    return {
      label, n, min, max, meanVal, medianVal, sd, q1, q3, iqr, lo, hi, outliersCount: outliers.length, skew
    };
  }

  // -------------------- Scatter render --------------------
  function renderScatter(xNums, yNums){
    const noteEl = document.getElementById('xyNote');
    const statsEl = document.getElementById('xyStats');
    const canvas = document.getElementById('xyScatter');

    destroyChart('xy');

    if (xNums.length === 0 || yNums.length === 0){
      noteEl.textContent = 'Provide both X and Y to view relationship.';
      statsEl.textContent = '—';
      // draw empty axes? keep blank
      charts.xy = new Chart(canvas, {
        type: 'scatter',
        data: { datasets: [] },
        options: {
          responsive:true,
          plugins:{ legend:{ display:false } },
          scales:{ x:{ }, y:{ } }
        }
      });
      return { report:'No X–Y relationship computed (missing X or Y).' };
    }

    const nPairs = Math.min(xNums.length, yNums.length);
    const usedX = xNums.slice(0, nPairs);
    const usedY = yNums.slice(0, nPairs);

    const r = pearsonR(usedX, usedY);
    const reg = linearRegression(usedX, usedY);

    const pts = [];
    for (let i=0;i<nPairs;i++) pts.push({ x: usedX[i], y: usedY[i] });

    const xmin = Math.min(...usedX), xmax = Math.max(...usedX);
    const x1 = xmin, x2 = xmax;
    const y1 = reg.intercept + reg.slope * x1;
    const y2 = reg.intercept + reg.slope * x2;

    const lenNote = (xNums.length !== yNums.length)
      ? `Using ${nPairs} paired observations (min(nX,nY)).`
      : `Using ${nPairs} paired observations.`;

    noteEl.textContent = lenNote;

    const rTxt = Number.isFinite(r) ? fmt(r) : '—';
    const slopeTxt = Number.isFinite(reg.slope) ? fmt(reg.slope) : '—';
    const intTxt = Number.isFinite(reg.intercept) ? fmt(reg.intercept) : '—';

    statsEl.innerHTML =
      `Pearson correlation <span class="mono">r = ${rTxt}</span>. ` +
      `Linear regression: <span class="mono">y = ${slopeTxt}·x + ${intTxt}</span>.`;

    charts.xy = new Chart(canvas, {
      type: 'scatter',
      data: {
        datasets: [
          {
            label: 'Pairs',
            data: pts,
            pointRadius: 3,
            pointHoverRadius: 5
          },
          {
            label: 'Regression line',
            type: 'line',
            data: [{ x: x1, y: y1 }, { x: x2, y: y2 }],
            pointRadius: 0,
            borderWidth: 2,
            tension: 0
          }
        ]
      },
      options: {
        responsive:true,
        plugins:{ legend:{ display:false } },
        scales:{
          x:{ title:{ display:true, text:'X' } },
          y:{ title:{ display:true, text:'Y' } }
        }
      }
    });

    return {
      report: `X–Y relationship: paired by index, nPairs=${nPairs}, Pearson r=${rTxt}, regression y=${slopeTxt}·x+${intTxt}.`
    };
  }

  // -------------------- Report text --------------------
  function buildReportText(one, title){
    if (!one) return `${title}: no data.`;
    const sdPart = Number.isFinite(one.sd) ? ` (SD = ${fmt(one.sd)})` : '';
    const outPart = (one.outliersCount > 0)
      ? ` Outliers by Tukey’s rule (< ${fmt(one.lo)} or > ${fmt(one.hi)}; count = ${one.outliersCount}).`
      : ` No outliers by Tukey’s rule (fences: < ${fmt(one.lo)} or > ${fmt(one.hi)}).`;

    return (
      `${title} (n = ${one.n}). Distribution: ${one.skew.short}. ` +
      `Median = ${fmt(one.medianVal)} (IQR = ${fmt(one.iqr)}; Q1 = ${fmt(one.q1)}, Q3 = ${fmt(one.q3)}). ` +
      `Mean = ${fmt(one.meanVal)}${sdPart}. Range: min = ${fmt(one.min)}, max = ${fmt(one.max)}.` +
      outPart
    );
  }

  // -------------------- Clipboard --------------------
  async function copyToClipboard(text){
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (e) {
      try {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly', '');
        ta.style.position = 'absolute';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
      } catch {
        return false;
      }
    }
  }

  // -------------------- Main render --------------------
  const elX = document.getElementById('dataX');
  const elY = document.getElementById('dataY');
  const elToast = document.getElementById('toast');
  const btnCopy = document.getElementById('copyReport');

  let lastReport = '';
  function setToast(msg){ elToast.textContent = msg; }

  function analyze(){
    hideTip();

    const px = parseNumbers(elX.value);
    const py = parseNumbers(elY.value);

    const xSummary = renderVariable('x', 'X', px.nums, px.bad);
    const ySummary = renderVariable('y', 'Y', py.nums, py.bad);
    const xy = renderScatter(px.nums, py.nums);

    lastReport =
      buildReportText(xSummary, 'Variable X') + '\n' +
      buildReportText(ySummary, 'Variable Y') + '\n' +
      xy.report;

    btnCopy.disabled = false;
    setToast('Ready.');
  }

  // -------------------- Wire up --------------------
  document.getElementById('analyze').addEventListener('click', analyze);

  document.getElementById('example').addEventListener('click', () => {
    elX.value = "1, 2, 2, 3, 3, 4, 100\n5 6 7 8 9\n10";
    elY.value = "1, 1, 2, 2, 3, 5, 8, 13, 21\n34 55 89";
    analyze();
  });

  document.getElementById('clear').addEventListener('click', () => {
    elX.value = "";
    elY.value = "";
    document.getElementById('parseX').textContent = '—';
    document.getElementById('parseY').textContent = '—';
    document.getElementById('xStats').innerHTML = '';
    document.getElementById('yStats').innerHTML = '';
    document.getElementById('xInterp').style.display = 'none';
    document.getElementById('yInterp').style.display = 'none';
    document.getElementById('xyNote').textContent = 'Provide both X and Y to view relationship.';
    document.getElementById('xyStats').textContent = '—';

    destroyChart('xHist'); destroyChart('xDen');
    destroyChart('yHist'); destroyChart('yDen');
    destroyChart('xy');

    ['xBox','yBox'].forEach(id=>{
      const c = document.getElementById(id);
      c.getContext('2d').clearRect(0,0,c.width,c.height);
      BOX_GEOM.set(id, null);
    });

    btnCopy.disabled = true;
    lastReport = '';
    setToast('—');
  });

  btnCopy.addEventListener('click', async () => {
    const ok = await copyToClipboard(lastReport || '');
    setToast(ok ? 'Copied.' : 'Copy failed (browser blocked clipboard).');
  });

  // Attach box interactions (both)
  attachBoxInteractions(document.getElementById('xBox'));
  attachBoxInteractions(document.getElementById('yBox'));

  // keep crisp after resize (recompute)
  window.addEventListener('resize', () => {
    // only re-run if something was analyzed
    if (btnCopy.disabled) return;
    analyze();
  });
</script>
</body>
</html>
